# Database Conventions

This document explains BACKDRP.FM's database architecture, collection naming strategy, and data conventions.

## Architecture Overview

BACKDRP.FM uses a **unified collection naming strategy** across all environments with **project-level isolation**.

### Key Principles

1. **All environments use the same collection names**
2. **Environment isolation through separate Firebase projects**
3. **Test data identified by document ID convention**
4. **No collection prefixes**

## Collection Naming Strategy

### Unified Collections

All Firebase environments (dev, staging, production) use **identical collection names**:

```
videos
artists
users
playlists
mailingList
```

**No prefixes** like `dev_videos` or `staging_artists` are used.

### Why This Approach?

**Advantages:**
- ✅ **Consistent code** - Same queries work across all environments
- ✅ **Simpler codebase** - No environment-specific logic
- ✅ **Easier testing** - Test code matches production code exactly
- ✅ **Reduced bugs** - No conditional collection name logic to maintain
- ✅ **Better DX** - Developers don't need to think about prefixes

**How isolation is achieved:**
- Each environment uses a **separate Firebase project**
- Dev: `backdrp-fm-dev`
- Staging: `backdrp-fm-staging`
- Production: `backdrp-fm-prod-4215e`

### Code Example

```dart
// lib/config/environment.dart
static String getCollectionName(String baseName) {
  return baseName; // No prefixes!
}

// Usage - same across all environments
FirebaseFirestore.instance
  .collection('videos')  // Always 'videos', never 'dev_videos'
  .where('status', isEqualTo: 'published')
```

## Test Data Convention

### Document ID Prefixes

While collection names are unified, **test data uses document ID prefixes** to distinguish seeded test data from real user-generated content:

```dart
// Test data document IDs use 'dev_' prefix
dev_video_001
dev_video_002
dev_artist_pendulum
dev_user_john
dev_playlist_house_classics

// Real user data uses generated IDs
aB3dEfGh1JkLmNoPqRsT  // Generated by Firestore
uV4wXyZ2AbCdEfGh1JkL  // User-created content
```

### Why ID Prefixes?

**Benefits:**
- ✅ Easy to identify test data at a glance
- ✅ Can filter out test data if needed
- ✅ Safe to delete all `dev_*` documents
- ✅ Production data is easily distinguishable

**Usage:**
```dart
// Seeding test data
await FirebaseFirestore.instance
  .collection('videos')
  .doc('dev_video_001')  // Explicit ID with prefix
  .set(testVideoData);

// Real user data
await FirebaseFirestore.instance
  .collection('videos')
  .add(userVideoData);  // Auto-generated ID
```

## Collection Schemas

### Videos Collection

```typescript
videos/{videoId}
{
  id: string,
  youtubeUrl: string,
  youtubeId: string,
  thumbnailUrl: string,
  title: string,
  artist: string,
  artistId: string,  // Reference to artists/{artistId}
  description: string,
  genres: string[],
  location: {
    venue: string,
    city: string,
    country: string,
    latitude?: number,
    longitude?: number
  },
  duration: number,
  recordedDate?: Timestamp,
  publishedDate?: Timestamp,
  status: 'draft' | 'published',
  likes: number,
  views: number,
  featured: boolean,
  sortOrder: number,
  tags: string[]
}
```

**Indexes required:**
- `status ASC, publishedDate DESC`
- `featured ASC, sortOrder ASC`
- `artistId ASC, status ASC, publishedDate DESC`

### Artists Collection

```typescript
artists/{artistId}
{
  id: string,
  name: string,
  bio: string,
  profileImageUrl: string,
  bannerImageUrl: string,
  socialLinks: {
    [platform: string]: string  // e.g., "spotify": "https://..."
  },
  genres: string[],
  location: string,
  totalSets: number,
  createdDate?: Timestamp,
  active: boolean
}
```

**Indexes required:**
- `active ASC, name ASC`

### Users Collection

```typescript
users/{userId}
{
  id: string,  // Matches Firebase Auth UID
  email: string,
  displayName: string,
  profileImageUrl?: string,
  role: 'user' | 'admin',
  favoriteGenres: string[],
  likedVideos: string[],  // Array of video IDs
  createdPlaylists: string[],  // Array of playlist IDs
  preferences: {
    notifications: boolean,
    autoplay: boolean,
    quality: string
  },
  createdDate: Timestamp,
  lastLoginDate: Timestamp
}
```

### Playlists Collection

```typescript
playlists/{playlistId}
{
  id: string,
  name: string,
  description: string,
  thumbnailUrl: string,
  createdBy: string,  // User ID
  videoIds: string[],  // Ordered array of video IDs
  genres: string[],
  featured: boolean,
  sortOrder: number,
  isPublic: boolean,
  createdDate: Timestamp,
  updatedDate: Timestamp
}
```

**Indexes required:**
- `featured ASC, sortOrder ASC`

## Security Rules

Security rules are **unified across all environments** since collections use the same names:

```javascript
// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function - works same in all environments
    function isAdmin() {
      return request.auth != null &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Videos - public read for published, admin write
    match /videos/{videoId} {
      allow read: if resource.data.status == 'published' || isAdmin();
      allow create, update, delete: if isAdmin();
    }

    // Artists - public read if active, admin write
    match /artists/{artistId} {
      allow read: if resource.data.active == true || isAdmin();
      allow create, update, delete: if isAdmin();
    }

    // Users - authenticated read, owner/admin write
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth.uid == userId || isAdmin();
    }

    // Playlists - public read, creator/admin write
    match /playlists/{playlistId} {
      allow read: if resource.data.isPublic == true ||
                     request.auth.uid == resource.data.createdBy ||
                     isAdmin();
      allow create: if request.auth != null;
      allow update, delete: if request.auth.uid == resource.data.createdBy ||
                               isAdmin();
    }
  }
}
```

**Deploy rules to all environments:**
```bash
firebase deploy --only firestore:rules --project backdrp-fm-dev
firebase deploy --only firestore:rules --project backdrp-fm-staging
firebase deploy --only firestore:rules --project backdrp-fm-prod-4215e
```

## Firestore Indexes

Composite indexes are defined in `firestore.indexes.json` and deployed to all environments:

```json
{
  "indexes": [
    {
      "collectionGroup": "videos",
      "queryScope": "COLLECTION",
      "fields": [
        {"fieldPath": "status", "order": "ASCENDING"},
        {"fieldPath": "publishedDate", "order": "DESCENDING"}
      ]
    },
    {
      "collectionGroup": "artists",
      "queryScope": "COLLECTION",
      "fields": [
        {"fieldPath": "active", "order": "ASCENDING"},
        {"fieldPath": "name", "order": "ASCENDING"}
      ]
    }
  ]
}
```

**Deploy indexes:**
```bash
firebase deploy --only firestore:indexes --project backdrp-fm-dev
firebase deploy --only firestore:indexes --project backdrp-fm-staging
firebase deploy --only firestore:indexes --project backdrp-fm-prod-4215e
```

## Data Seeding

### Development & Staging

Use the seed script to populate test data:

```bash
# Seed development
node seed-all-test-data.js --project=backdrp-fm-dev

# Seed staging
node seed-all-test-data.js --project=backdrp-fm-staging
```

**What gets seeded:**
- 16 test videos with `dev_video_` prefix
- 10 test artists with `dev_artist_` prefix
- 6 test users with `dev_user_` prefix
- 6 test playlists with `dev_playlist_` prefix

### Production

**NEVER seed production!** Production data should only be added through:
- Admin panel in the app
- Manual Firebase Console entries
- Verified production scripts (with extreme caution)

## Querying Conventions

### Standard Queries

```dart
// Get published videos
final videos = await FirebaseFirestore.instance
  .collection('videos')
  .where('status', isEqualTo: 'published')
  .orderBy('publishedDate', descending: true)
  .limit(20)
  .get();

// Get active artists
final artists = await FirebaseFirestore.instance
  .collection('artists')
  .where('active', isEqualTo: true)
  .orderBy('name')
  .get();
```

### Filtering Test Data

If you need to exclude test data:

```dart
// In development, might want to show real and test data
final allVideos = await FirebaseFirestore.instance
  .collection('videos')
  .where('status', isEqualTo: 'published')
  .get();

// Filter out test data in code if needed
final realVideos = allVideos.docs
  .where((doc) => !doc.id.startsWith('dev_'))
  .toList();
```

## Migration Notes

### Previous Approach (Deprecated)

Previously, the codebase may have used prefixed collections:
- ❌ `dev_videos`, `dev_artists`, `dev_users`
- ❌ `staging_videos`, `staging_artists`, `staging_users`
- ❌ Production: `videos`, `artists`, `users`

**This approach was removed** in favor of unified naming.

### Migration Path

If you have old prefixed collections:

1. **Keep old data** in prefixed collections (don't delete)
2. **New data** goes in unified collections
3. **Gradually migrate** important data
4. **Eventually delete** old prefixed collections

The app now only uses unified collection names.

## Best Practices

### ✅ DO:
- Use unified collection names (`videos`, not `dev_videos`)
- Prefix test data document IDs with `dev_`
- Deploy security rules to all environments
- Deploy indexes to all environments
- Test queries in dev before promoting to staging/prod

### ❌ DON'T:
- Add collection prefixes based on environment
- Mix test data and production data in same Firebase project
- Seed production database
- Use `dev_` prefix for real user data
- Skip deploying security rules or indexes

## Troubleshooting

### Query requires an index

**Error:** `[cloud_firestore/failed-precondition] The query requires an index`

**Solution:**
1. Click the URL in the error message to create index in Firebase Console
2. Or add index to `firestore.indexes.json` and deploy:
   ```bash
   firebase deploy --only firestore:indexes --project backdrp-fm-dev
   ```

### Permission denied

**Error:** `[cloud_firestore/permission-denied]`

**Solution:**
1. Check security rules are deployed:
   ```bash
   firebase deploy --only firestore:rules --project backdrp-fm-dev
   ```
2. Verify user is authenticated
3. Check user has required role (e.g., admin)
4. Verify document meets read/write conditions

### Data appears in wrong environment

**Symptom:** Created data in dev but appears in prod

**Solution:**
1. Verify which launch configuration you're using
2. Check console output for Firebase project ID
3. Confirm VS Code task copied correct config files
4. See [VS Code Configuration Guide](VSCODE_CONFIGURATION.md)

## Related Documentation

- [VS Code Configuration](VSCODE_CONFIGURATION.md) - Environment setup
- [Firebase Setup](FIREBASE_SETUP.md) - Config file management
- [Environment Setup](../ENVIRONMENT_SETUP.md) - Multi-environment architecture
- [Development Guide](../DEVELOPMENT.md) - Running different environments

---

**Questions?** Refer to related documentation or ask in team discussions.
